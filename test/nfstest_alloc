#!/usr/bin/env python
#===============================================================================
# Copyright 2015 NetApp, Inc. All Rights Reserved,
# contribution by Jorge Mora <mora@netapp.com>
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#===============================================================================
import os
import time
import errno
import ctypes
import struct
import formatstr
import traceback
import nfstest_config as c
from nfstest.utils import *
from packet.nfs.nfs4_const import *
from nfstest.test_util import TestUtil
from fcntl import fcntl,F_WRLCK,F_SETLK

# Module constants
__author__    = "Jorge Mora (%s)" % c.NFSTEST_AUTHOR_EMAIL
__copyright__ = "Copyright (C) 2015 NetApp, Inc."
__license__   = "GPL v2"
__version__   = "1.2"

USAGE = """%prog --server <server> [options]

Space reservation tests
=======================
Verify correct functionality of space reservations so applications are
able to reserve or unreserve space for a file. The system call fallocate
is used to manipulate the allocated disk space for a file, either to
preallocate or deallocate it. For filesystems which support the fallocate
system call, preallocation is done quickly by allocating blocks and
marking them as uninitialized, requiring no I/O to the data blocks.
This is much faster than creating a file and filling it with zeros.

Basic allocate tests verify the disk space is actually preallocated or
reserved for the given range by filling up the device after the allocation
and make sure data can be written to the allocated range without any
problems. Also, any data written outside the allocated range will fail
with NFS4ERR_NOSPC when there is no more space left on the device.
On the other hand, deallocating space will give the disk space back
so it can be used by either the same file on regions not already
preallocated or by different files without the risk of getting
a no space error.

Performance testing using ALLOCATE versus initializing a file to all
zeros is also included. The performance comparison is done with different
file sizes.

Some tests include testing at the protocol level by taking a packet trace
and inspecting the actual packets sent to the server or servers.

Negative testing is included whenever possible since some testing cannot
be done at the protocol level because the fallocate system call does some
error checking of its own and the NFS client won't even send an ALLOCATE
or DEALLOCATE operation to the server letting the server deal with the
error. Negative tests include trying to allocate an invalid range, having
an invalid value for either the offset or the length, trying to allocate
or deallocate a region on a file opened as read only or the file is a
non-regular file type.

Examples:
    The only required option is --server
    $ %prog --server 192.168.0.11

Notes:
    The user id in the local host must have access to run commands as root
    using the 'sudo' command without the need for a password.

    Tests which require filling up all the disk space on the mounted device
    should have exclusive access to the device.

    Valid only for NFS version 4.2 and above."""

# Test script ID
SCRIPT_ID = "ALLOC"

ALLOC_TESTS = [
    "alloc01",
    "alloc02",
    "alloc03",
    "alloc04",
    "alloc05",
    "alloc06",
]
DEALLOC_TESTS = [
    "dealloc01",
    "dealloc02",
    "dealloc03",
    "dealloc04",
    "dealloc05",
    "dealloc06",
]
PERF_TESTS = [
    "perf01",
]

# Include the test groups in the list of test names
# so they are displayed in the help
TESTNAMES = ["alloc"] + ALLOC_TESTS + ["dealloc"] + DEALLOC_TESTS + PERF_TESTS

TESTGROUPS = {
    "alloc": {
         "tests": ALLOC_TESTS,
         "desc": "Run all ALLOCATE tests: ",
    },
    "dealloc": {
         "tests": DEALLOC_TESTS,
         "desc": "Run all DEALLOCATE tests: ",
    },
}

def getlock(fd, lock_type, offset=0, length=0):
    """Get byte range lock on file given by file descriptor"""
    lockdata = struct.pack('hhllhh', lock_type, 0, offset, length, 0, 0)
    out = fcntl(fd, F_SETLK, lockdata)
    return struct.unpack('hhllhh', out)

class AllocTest(TestUtil):
    """AllocTest object

       AllocTest() -> New test object

       Usage:
           x = AllocTest(testnames=['alloc01', 'alloc02', 'alloc03', ...])

           # Run all the tests
           x.run_tests()
           x.exit()
    """
    def __init__(self, **kwargs):
        """Constructor

           Initialize object's private data.
        """
        TestUtil.__init__(self, **kwargs)
        self.opts.version = "%prog " + __version__
        # Tests are valid for NFSv4.2 and beyond
        self.opts.set_defaults(nfsversion=4.2)
        # Option self.free_blocks
        hmsg = "Number of free blocks to use when trying to allocate all " + \
               "available space [default: %default]"
        self.test_opgroup.add_option("--free-blocks", type="int", default=64, help=hmsg)
        # Option self.perf_fsize
        hmsg = "Starting file size for the perf01 test [default: %default]"
        self.test_opgroup.add_option("--perf-fsize", default="1MB", help=hmsg)
        # Option self.perf_mult
        hmsg = "File size multiplier for the perf01 test, the tests are " + \
               "performed for a file size which is a multiple of the " + \
               "previous test file size [default: %default]"
        self.test_opgroup.add_option("--perf-mult", type="int", default=4, help=hmsg)
        # Option self.perf_time
        hmsg = "Run the performance test perf01 until the sub-test for " + \
               "the current file size executes for more than this time " + \
               "[default: %default]"
        self.test_opgroup.add_option("--perf-time", type="int", default=15, help=hmsg)
        self.scan_options()

        # Convert units
        self.perf_fsize = formatstr.int_units(self.perf_fsize)

        # Disable createtraces option but save it first for tests that do not
        # check the NFS packets to verify the assertion
        self._createtraces = self.createtraces
        self.createtraces = False

    def setup(self, **kwargs):
        """Setup test environment"""
        self.umount()
        self.mount()
        # Get block size for mounted volume
        self.statvfs = os.statvfs(self.mtdir)
        super(AllocTest, self).setup(**kwargs)
        self.umount()

    def verify_fallocate(self, fd, offset, size, **kwargs):
        """Verify fallocate works as expected

           fd:
               Allocate/deallocate disk space for the file referred
               to by this file handle
           offset:
               Starting offset where the allocation or deallocation
               takes place
           size:
               Length of region in file to allocate or deallocate
           msg:
               Message appended to assertion [default: ""]
           smsg:
               Message appended to file size assertion [default: ""]
           dmsg:
               Debug message to display [default: None]
           absfile:
               File name to display in default debug message
               [default: self.absfile]
           ftype:
               File type [default: "file"]
           error:
               Expected error [default: None]
           dealloc:
               Verify deallocate when set to True [default: False]
        """
        msg     = kwargs.pop("msg", "")
        smsg    = kwargs.pop("smsg", "")
        dmsg    = kwargs.pop("dmsg", None)
        absfile = kwargs.pop("absfile", self.absfile)
        ftype   = kwargs.pop("ftype", "file")
        error   = kwargs.pop("error", None)
        dealloc = kwargs.pop("dealloc", False)
        err = 0
        fmsg = ""

        if dealloc:
            mode  = SR_DEALLOCATE
            opstr = "Deallocate"
        else:
            mode  = SR_ALLOCATE
            opstr = "Allocate"

        s_msg = opstr.lower() + smsg
        if dmsg is None:
            dmsg = "%s %s %s starting at offset %d with length %d" % (opstr, ftype, absfile, offset, size)

        # Get the size of file
        fstat = os.fstat(fd)
        esize = fstat.st_size

        self.dprint('DBG3', dmsg)
        out = self.libc.fallocate(fd, mode, offset, size)
        if out == -1:
            err = ctypes.get_errno()
            errstr = errno.errorcode.get(err,err)
            fmsg = ", got error [%s] %s" % (errstr, os.strerror(err))
        elif error:
            fmsg = ", but it succeeded"

        if error is None:
            # Expecting fallocate to succeed
            self.test(out == 0, "%s should succeed %s" % (opstr, msg), failmsg=fmsg)
            if dealloc:
                tmsg = "File size should not change after %s" % s_msg
            else:
                esize = max(esize, offset+size)
                tmsg = "File size should be correct after %s" % s_msg
        else:
            # Expecting fallocate to fail
            tmsg = "File size should not change after a failed %s" % s_msg
            errorstr = errno.errorcode.get(error,error)
            self.test(out == -1 and err == error, "%s should fail with %s %s" % (opstr, errorstr, msg), failmsg=fmsg)

        if ftype == "file":
            fstat = os.fstat(fd)
            tfmsg = ", expecting file size %d and got %d" % (esize, fstat.st_size)
            self.test(esize == fstat.st_size, tmsg, failmsg=tfmsg)

        return out

    def verify_allocate(self, offset, size, **kwargs):
        """Verify client sends ALLOCATE/DEALLOCATE with correct arguments

           offset:
               Starting offset of allocation or deallocation
           size:
               Length of region in file to allocate or deallocate
           stateid:
               Expected stateid in call [default: self.stateid]
           status:
               Expected status in reply [default: NFS4_OK]
           dealloc:
               Verify DEALLOCATE when set to True [default: False]
        """
        status  = kwargs.pop("status",  NFS4_OK)
        stateid = kwargs.pop("stateid", self.stateid)
        dealloc = kwargs.pop("dealloc", False)
        mstatus = nfsstat4.get(status, status)

        nfsop = OP_DEALLOCATE if dealloc else OP_ALLOCATE
        opstr = "DEALLOCATE"  if dealloc else "ALLOCATE"

        # Find next ALLOCATE/DEALLOCATE call and reply
        (pktcall, pktreply) = self.find_nfs_op(nfsop, status=None)
        self.dprint('DBG7', str(pktcall))
        self.dprint('DBG7', str(pktreply))

        self.test(pktcall, "%s should be sent to the server" % opstr)
        if pktcall is None:
            return

        allocobj = pktcall.NFSop

        fmsg = ", expecting 0x%08x but got 0x%08x" % (formatstr.crc32(stateid), formatstr.crc32(allocobj.stateid.other))
        self.test(allocobj.stateid == stateid, "%s should be sent with correct stateid" % opstr, failmsg=fmsg)
        fmsg = ", expecting %d but got %d" % (offset, allocobj.offset)
        self.test(allocobj.offset == offset, "%s should be sent with correct offset" % opstr, failmsg=fmsg)
        fmsg = ", expecting %d but got %d" % (size, allocobj.length)
        self.test(allocobj.length == size, "%s should be sent with correct length" % opstr, failmsg=fmsg)

        if status == NFS4_OK:
            msg = "%s should return NFS4_OK" % opstr
        else:
            msg = "%s should fail with %s when whole range cannot be guaranteed" % (opstr, mstatus)

        if pktreply:
            rstatus = pktreply.nfs.status
            fmsg = ", expecting %s but got %s" % (mstatus, nfsstat4.get(rstatus, rstatus))
        else:
            rstatus = None
            fmsg = ""
        self.test(pktreply and rstatus == status, msg, failmsg=fmsg)

    def alloc01(self, open_mode, offset=0, size=None, msg="", lock=False, dealloc=False):
        """Main test to verify ALLOCATE/DEALLOCATE succeeds on files opened as
           write only or read and write.

           open_mode:
               Open mode, either O_WRONLY or O_RDWR
           offset:
               Starting offset where the allocation or deallocation will take
               place [default: 0]
           size:
               Length of region in file to allocate or deallocate.
               [default: --filesize option]
           msg:
               String to identify the specific test running and it is appended
               to the main assertion message [default: ""]
           lock:
               Lock file before doing the allocate/deallocate [default: False]
           dealloc:
               Run the DEALLOCATE test when set to True [default: False]
        """
        try:
            fd = None
            if size is None:
                # Default size to allocate or deallocate
                size = self.filesize

            self.test_info("====  %s test %02d%s" % (self.testname, self.testidx, msg))
            self.testidx += 1
            self.umount()

            if open_mode == os.O_RDWR or dealloc:
                # Mount device to create a new file, this file should already
                # exist for the test
                self.mount()

            if open_mode == os.O_WRONLY:
                open_str = "writing"
                o_str = "write only"
                if dealloc:
                    # Create a new file for deallocate tests
                    self.create_file()
                else:
                    # Get a new file name
                    self.get_filename()
                drange = [0, 0]
                zrange = [offset, size]
            else:
                open_str = "read and write"
                o_str = open_str
                # Create a new file to have an existing file for the test
                self.create_file()
                # No change on current data should be expected on allocate
                drange = [0, self.filesize]
                if offset+size > self.filesize:
                    # Allocate range is beyond the end of the file so zero data
                    # should be expected beyond the end of the current file size
                    zrange = [self.filesize, offset+size-self.filesize]
                else:
                    # Allocate range is fully inside the current file size thus
                    # all data should remained intact -- no zeros
                    zrange = [0, 0]

            if dealloc:
                nfsop = OP_DEALLOCATE
                opstr = "Deallocate"

                if offset >= self.filesize:
                    # Deallocate range is fully outside the current file size
                    # so all data should remained intact -- no zeros
                    drange = [0, self.filesize]
                    zrange = [0, 0]
                elif offset+size > self.filesize:
                    # Deallocate range is partially outside the current file
                    # size thus data should remain intact from the start of
                    # the file to the start of the deallocated range and
                    # zero data should be expected starting from offset to
                    # the end of the file -- file size should not change
                    drange = [0, offset]
                    zrange = [offset, self.filesize-offset]
                else:
                    # Deallocate range is fully inside the current file size
                    # thus zero data should be expected on the entire
                    # deallocated range and all data outside this range should
                    # be left intact
                    drange = [0, offset]
                    if offset+size < self.filesize:
                        drange += [offset+size, self.filesize-offset-size]
                    zrange = [offset, size]
            else:
                nfsop = OP_ALLOCATE
                opstr = "Allocate"

            self.umount()
            self.trace_start()
            self.mount()

            self.dprint('DBG3', "Open file %s for %s" % (self.absfile, open_str))
            fd = os.open(self.absfile, open_mode|os.O_CREAT)

            if lock:
                self.dprint('DBG3', "Lock file %s starting at offset %d with length %d" % (self.absfile, offset, size))
                getlock(fd, F_WRLCK, offset, size)

            # Allocate or deallocate test range
            tmsg = "when the file is opened as %s" % o_str
            self.verify_fallocate(fd, offset, size, msg=tmsg, smsg=msg, dealloc=dealloc)
            os.close(fd)
            fd = None

            # Verify the contents of the file are correct, data and zero regions
            self.dprint('DBG3', "Open file %s for reading" % self.absfile)
            fd = os.open(self.absfile, os.O_RDONLY)

            if drange[1] > 0:
                # Read from range where previous file data is expected
                self.dprint('DBG4', "Read file %s %d @ %d" % (self.absfile, drange[1], drange[0]))
                os.lseek(fd, drange[0], 0)
                rdata = os.read(fd, drange[1])
                wdata = self.data_pattern(drange[0], drange[1])
                if dealloc:
                    tmsg = "Read from file before deallocated range should return the file data"
                else:
                    tmsg = "Read from allocated range within the previous file size should return the file data"
                self.test(rdata == wdata, tmsg)
            if len(drange) > 2 and drange[3] > 0:
                # Read from second range where previous file data is expected
                self.dprint('DBG4', "Read file %s %d @ %d" % (self.absfile, drange[3], drange[2]))
                os.lseek(fd, drange[2], 0)
                rdata = os.read(fd, drange[3])
                wdata = self.data_pattern(drange[2], drange[3])
                self.test(rdata == wdata, "Read from file after deallocated range should return the file data")

            if zrange[1] > 0:
                # Read from range where zero data is expected
                self.dprint('DBG4', "Read file %s %d @ %d" % (self.absfile, zrange[1], zrange[0]))
                os.lseek(fd, zrange[0], 0)
                rdata = os.read(fd, zrange[1])
                wdata = "\x00" * zrange[1]
                if dealloc:
                    tmsg = "Read from deallocated range inside the previous file size should return zeros"
                else:
                    tmsg = "Read from allocated range outside the previous file size should return zeros"
                self.test(rdata == wdata, tmsg)
        except Exception:
            self.test(False, traceback.format_exc())
        finally:
            if fd:
                os.close(fd)
            self.umount()
            self.trace_stop()

        try:
            # Process the packet trace to inspect the NFS packets
            self.trace_open()
            self.set_pktlist()
            # Get the correct state id for the ALLOCATE/DEALLOCATE operation
            self.get_stateid(self.filename, write=True)

            # Verify ALLOCATE/DEALLOCATE packet call and reply
            self.verify_allocate(offset, size, dealloc=dealloc)
        except Exception:
            self.test(False, traceback.format_exc())
        finally:
            self.pktt.close()

    def alloc01_test(self):
        """Verify ALLOCATE succeeds on files opened as write only"""
        self.test_group("Verify ALLOCATE succeeds on files opened as write only")
        blocksize = self.statvfs.f_bsize
        self.testidx = 1

        self.alloc01(os.O_WRONLY)
        msg1 = " for a range not starting at the beginning of the file"
        self.alloc01(os.O_WRONLY, offset=blocksize, size=self.filesize, msg=msg1)
        msg2 = " for a range starting at a non-aligned block size boundary"
        self.alloc01(os.O_WRONLY, offset=blocksize/2, size=blocksize+blocksize/2, msg=msg2)
        msg3 = " for a range ending at a non-aligned block size boundary"
        self.alloc01(os.O_WRONLY, offset=0, size=blocksize+blocksize/2, msg=msg3)
        msg4 = " for a range starting and ending at a non-aligned block size boundary"
        self.alloc01(os.O_WRONLY, offset=blocksize/2, size=blocksize, msg=msg4)

        if hasattr(self, "deleg_stateid") and self.deleg_stateid is None:
            # Run tests with byte range locking
            msg = " (locking file)"
            self.alloc01(os.O_WRONLY, msg=msg, lock=True)
            self.alloc01(os.O_WRONLY, offset=blocksize, size=self.filesize, msg=msg1+msg, lock=True)
            self.alloc01(os.O_WRONLY, offset=blocksize/2, size=blocksize+blocksize/2, msg=msg2+msg, lock=True)
            self.alloc01(os.O_WRONLY, offset=0, size=blocksize+blocksize/2, msg=msg3+msg, lock=True)
            self.alloc01(os.O_WRONLY, offset=blocksize/2, size=blocksize, msg=msg4+msg, lock=True)

    def alloc02_test(self):
        """Verify ALLOCATE succeeds on files opened as read and write"""
        self.test_group("Verify ALLOCATE succeeds on files opened as read and write")
        blocksize = self.statvfs.f_bsize
        self.testidx = 1

        self.alloc01(os.O_RDWR)
        msg1 = " for a range not starting at the beginning of the file"
        self.alloc01(os.O_RDWR, offset=blocksize, size=self.filesize, msg=msg1)
        msg2 = " for a range starting at a non-aligned block size boundary"
        self.alloc01(os.O_RDWR, offset=blocksize/2, size=blocksize+blocksize/2, msg=msg2)
        msg3 = " for a range ending at a non-aligned block size boundary"
        self.alloc01(os.O_RDWR, offset=0, size=blocksize+blocksize/2, msg=msg3)
        msg4 = " for a range starting and ending at a non-aligned block size boundary"
        self.alloc01(os.O_RDWR, offset=blocksize/2, size=blocksize, msg=msg4)
        msg5 = " when range is fully inside the current file size"
        self.alloc01(os.O_RDWR, offset=self.filesize/4, size=self.filesize/2, msg=msg5)
        msg6 = " when range is partially outside the current file size"
        self.alloc01(os.O_RDWR, offset=self.filesize/2, size=self.filesize, msg=msg6)
        msg7 = " when range is fully outside the current file size"
        self.alloc01(os.O_RDWR, offset=self.filesize, size=self.filesize, msg=msg7)

        if hasattr(self, "deleg_stateid") and self.deleg_stateid is None:
            # Run tests with byte range locking
            msg = " (locking file)"
            self.alloc01(os.O_RDWR, msg=msg, lock=True)
            self.alloc01(os.O_RDWR, offset=blocksize, size=self.filesize, msg=msg1+msg, lock=True)
            self.alloc01(os.O_RDWR, offset=blocksize/2, size=blocksize+blocksize/2, msg=msg2+msg, lock=True)
            self.alloc01(os.O_RDWR, offset=0, size=blocksize+blocksize/2, msg=msg3+msg, lock=True)
            self.alloc01(os.O_RDWR, offset=blocksize/2, size=blocksize, msg=msg4+msg, lock=True)
            self.alloc01(os.O_RDWR, offset=self.filesize/4, size=self.filesize/2, msg=msg5+msg, lock=True)
            self.alloc01(os.O_RDWR, offset=self.filesize/2, size=self.filesize, msg=msg6+msg, lock=True)
            self.alloc01(os.O_RDWR, offset=self.filesize, size=self.filesize, msg=msg7+msg, lock=True)

    def alloc03(self, dealloc=False):
        """Main test to verify ALLOCATE/DEALLOCATE fails on files opened
           as read only

           dealloc:
               Run the DEALLOCATE test when set to True [default: False]
        """
        try:
            fd = None
            self.umount()
            if self._createtraces:
                # Just capture the packet trace when --createtraces is set
                self.trace_start()
            self.mount()

            # Use an existing file
            absfile = self.abspath(self.files[0])
            self.dprint('DBG3', "Open file %s for reading" % absfile)
            fd = os.open(absfile, os.O_RDONLY)

            # Allocate or deallocate test range
            tmsg = "when the file is opened as read only"
            self.verify_fallocate(fd, 0, self.filesize, absfile=absfile, msg=tmsg, error=errno.EBADF, dealloc=dealloc)
        except Exception:
            self.test(False, traceback.format_exc())
        finally:
            if fd:
                os.close(fd)
            self.umount()
            self.trace_stop()
            self.trace_open()
            self.pktt.close()

    def alloc03_test(self):
        """Verify ALLOCATE fails on files opened as read only"""
        self.test_group("Verify ALLOCATE fails on files opened as read only")
        self.alloc03()

    def alloc04(self, dealloc=False):
        """Verify DE/ALLOCATE fails with EINVAL for invalid offset or length

           dealloc:
               Run the DEALLOCATE test when set to True [default: False]
        """
        try:
            fd = None
            self.umount()
            if self._createtraces:
                # Just capture the packet trace when --createtraces is set
                self.trace_start()
            self.mount()

            if dealloc:
                # Create a new file
                self.create_file()
            else:
                # Get a new file name
                self.get_filename()

            self.dprint('DBG3', "Open file %s for writing" % self.absfile)
            fd = os.open(self.absfile, os.O_WRONLY|os.O_CREAT)

            # Use an invalid offset
            tmsg = "when the offset is invalid"
            self.verify_fallocate(fd, -1, self.filesize, msg=tmsg, error=errno.EINVAL, dealloc=dealloc)

            # Use an invalid length
            tmsg = "when the length is invalid"
            self.verify_fallocate(fd, 0, 0, msg=tmsg, error=errno.EINVAL, dealloc=dealloc)
        except Exception:
            self.test(False, traceback.format_exc())
        finally:
            if fd:
                os.close(fd)
            self.umount()
            self.trace_stop()
            self.trace_open()
            self.pktt.close()

    def alloc04_test(self):
        """Verify ALLOCATE fails with EINVAL for invalid offset or length"""
        self.test_group("Verify ALLOCATE fails EINVAL for invalid offset or length")
        self.alloc04()

    def alloc05(self, dealloc=False):
        """Verify DE/ALLOCATE fails with ESPIPE when using a named pipe file handle

           dealloc:
               Run the DEALLOCATE test when set to True [default: False]
        """
        try:
            fd = None
            pid = None
            self.umount()
            if self._createtraces:
                # Just capture the packet trace when --createtraces is set
                self.trace_start()
            self.mount()
            # Get a new file name
            self.get_filename()

            self.dprint('DBG3', "Create named pipe %s" % self.absfile)
            os.mkfifo(self.absfile)

            # Create another process for reading the named pipe
            pid = os.fork()
            if pid == 0:
                try:
                    fd = os.open(self.absfile, os.O_RDONLY)
                    os.read(fd)
                    os.close(fd)
                finally:
                    os._exit(0)

            self.dprint('DBG3', "Open named pipe %s for writing" % self.absfile)
            fd = os.open(self.absfile, os.O_WRONLY)

            tmsg = "when using a named pipe file handle"
            self.verify_fallocate(fd, 0, self.filesize, ftype="named pipe", msg=tmsg, error=errno.ESPIPE, dealloc=dealloc)

            os.close(fd)
            fd = None
        except Exception:
            self.test(False, traceback.format_exc())
        finally:
            if pid is not None:
                # Reap the background reading process
                (pid, out) = os.waitpid(pid, 0)
            if fd:
                os.close(fd)
            self.umount()
            self.trace_stop()
            self.trace_open()
            self.pktt.close()

    def alloc05_test(self):
        """Verify ALLOCATE fails with ESPIPE when using a named pipe file handle"""
        self.test_group("Verify ALLOCATE fails ESPIPE when using a named pipe file handle")
        self.alloc05()

    def alloc06(self, msg="", lock=False):
        """Verify ALLOCATE reserves the disk space

           msg:
               String to identify the specific test running and it is appended
               to the main assertion message [default: ""]
           lock:
               Lock file before doing the allocate/deallocate [default: False]
        """
        try:
            fd = None
            fd1 = None
            rmfile = None
            otherfile = None
            offset = 0
            size = 4*self.filesize
            free_space = self.free_blocks * self.statvfs.f_bsize

            self.test_info("====  %s test %02d%s" % (self.testname, self.testidx, msg))
            self.testidx += 1

            self.umount()
            self.trace_start()
            self.mount()

            # Get a new file name
            self.get_filename()
            filename = self.filename
            testfile = self.absfile
            self.dprint('DBG3', "Open file %s for writing" % testfile)
            fd = os.open(testfile, os.O_WRONLY|os.O_CREAT)

            if lock:
                self.dprint('DBG3', "Lock file %s starting at offset %d with length %d" % (testfile, offset, size))
                out = getlock(fd, F_WRLCK, offset, size)

            tmsg = "when the file is opened as write only"
            self.verify_fallocate(fd, offset, size, absfile=testfile, msg=tmsg)
            self.dprint('DBG5', "Available disk space %s" % formatstr.str_units(self.get_freebytes()))

            # Get a new file name
            self.get_filename()
            maxfile = self.filename
            rmfile  = self.absfile
            self.dprint('DBG3', "Open file %s for writing" % rmfile)
            fd1 = os.open(rmfile, os.O_WRONLY|os.O_CREAT)

            maxsize = self.get_freebytes() - free_space
            tmsg = "when allocating the maximum number of blocks left on the device"
            dmsg = "Allocate file %s with length of %s (available disk space minus %s) " % \
                   (rmfile, formatstr.str_units(maxsize), formatstr.str_units(free_space))
            out = self.verify_fallocate(fd1, 0, maxsize, msg=tmsg, dmsg=dmsg)
            if out == -1: return
            self.dprint('DBG5', "Available disk space %s" % formatstr.str_units(self.get_freebytes()))

            # Check if space was actually allocated
            if self.get_freebytes() > free_space:
                self.test(False, "Space was not actually allocated -- skipping rest of the test")
                return

            # Use the rest of the remaining space and a little bit more
            filesize = self.get_freebytes() + self.filesize

            try:
                fmsg = ", expecting ENOSPC but it succeeded"
                werrno = 0
                self.create_file(size=filesize)
            except OSError as werror:
                werrno = werror.errno
                fmsg = ", expecting ENOSPC but got %s" % errno.errorcode.get(werrno, werrno)
            expr = werrno == errno.ENOSPC
            self.test(expr, "Write to a different file should fail with ENOSPC when no space is left on the device", failmsg=fmsg)
            otherfile = self.filename
            self.dprint('DBG5', "Available disk space %s" % formatstr.str_units(self.get_freebytes()))

            tmsg = "when whole range cannot be guaranteed"
            self.verify_fallocate(fd, offset+size, filesize, absfile=testfile, msg=tmsg, error=errno.ENOSPC)
            self.dprint('DBG5', "Available disk space %s" % formatstr.str_units(self.get_freebytes()))

            try:
                fmsg = ", expecting ENOSPC but it succeeded"
                werrno = 0
                os.lseek(fd, offset+size, 0)
                data = self.data_pattern(offset+size, filesize)
                self.dprint('DBG3', "Write file %s %d@%d" % (testfile, len(data), offset+size))
                count = os.write(fd, data)
                os.fsync(fd)
            except OSError as werror:
                werrno = werror.errno
                fmsg = ", expecting ENOSPC but got %s" % errno.errorcode.get(werrno, werrno)
            expr = werrno == errno.ENOSPC
            self.test(expr, "Write outside the allocated region should fail with ENOSPC when no space is left on the device", failmsg=fmsg)
            self.dprint('DBG5', "Available disk space %s" % formatstr.str_units(self.get_freebytes()))

            os.lseek(fd, offset, 0)
            data = self.data_pattern(offset, size, pattern="\x55\xaa")
            self.dprint('DBG3', "Write file %s %d@%d" % (testfile, len(data), offset))
            count = os.write(fd, data)
            os.fsync(fd)
            self.test(count > 0, "Write within the allocated region should succeed when no space is left on the device"+msg)
            self.dprint('DBG5', "Available disk space %s" % formatstr.str_units(self.get_freebytes()))
        except Exception:
            self.test(False, traceback.format_exc())
        finally:
            if fd:
                try:
                    os.close(fd)
                except:
                    pass
            if fd1:
                os.close(fd1)
            if rmfile:
                os.unlink(rmfile)
            self.umount()
            self.trace_stop()

        try:
            self.set_nfserr_list(nfs4list=[NFS4ERR_NOENT, NFS4ERR_NOSPC])
            self.trace_open()
            self.set_pktlist()

            # Find OPEN and correct stateid to use for the other file
            self.get_stateid(maxfile)
            other_stateid = self.stateid

            # Find OPEN and correct stateid to use
            self.pktt.rewind(0)
            self.get_stateid(filename, noreset=True)
            save_index = self.pktt.get_index()

            # Verify ALLOCATE packet call and reply
            self.verify_allocate(offset, size)

            # Verify ALLOCATE which allocates the rest of the disk space
            self.verify_allocate(0, maxsize, stateid=other_stateid)

            # Verify second ALLOCATE for file
            self.verify_allocate(offset+size, filesize, status=NFS4ERR_NOSPC)

            # Rewind packet trace to search for WRITEs
            in_alloc  = True
            out_alloc = False
            non_alloc = False
            in_alloc_cnt  = 0
            out_alloc_cnt = 0
            non_alloc_cnt = 0
            while True:
                self.pktt.rewind(save_index)
                (pktcall, pktreply) = self.find_nfs_op(OP_WRITE, status=None)
                if not pktcall:
                    break
                save_index = pktcall.record.index + 1
                writeobj = pktcall.NFSop
                if writeobj.stateid == self.stateid:
                    # WRITE sent to allocated file
                    if writeobj.offset < offset+size:
                        # WRITE sent to allocated region
                        in_alloc_cnt += 1
                        if pktreply.nfs.status != NFS4_OK:
                            in_alloc = False
                    else:
                        # WRITE sent to non-allocated region
                        out_alloc_cnt += 1
                        if pktreply.nfs.status == NFS4ERR_NOSPC:
                            out_alloc = True
                else:
                    # WRITE sent to non-allocated file
                    non_alloc_cnt += 1
                    if pktreply.nfs.status == NFS4ERR_NOSPC:
                        non_alloc = True
            if in_alloc_cnt > 0:
                self.test(in_alloc, "WRITE within the allocated region should succeed when no space is left on the device")
            else:
                self.test(False, "WRITE within the allocated region should be sent")
            if out_alloc_cnt > 0:
                self.test(out_alloc, "WRITE outside the allocated region should fail with NFS4ERR_NOSPC when no space is left on the device")
            else:
                self.test(False, "WRITE outside the allocated region should be sent")
            if non_alloc_cnt > 0:
                self.test(non_alloc, "WRITE sent to non-allocated file should return NFS4ERR_NOSPC when no space is left on the device")
            else:
                # No writes found for other file, look for OPEN to check if
                # it failed on open instead
                self.pktt.rewind(0)
                file_str = "NFS.claim.name == '%s'" % otherfile
                (pktcall, pktreply) = self.find_nfs_op(OP_OPEN, match=file_str, status=None)
                if pktreply is None:
                    # Could not find OPEN, fail with the write error below
                    status = NFS4_OK
                else:
                    status = pktreply.NFSop.status
                if status != NFS4_OK:
                    fmsg = ", expecting NFS4ERR_NOSPC but got %s" % nfsstat4.get(status, status)
                    self.test(status == NFS4ERR_NOSPC, "OPEN sent to non-allocated file should return NFS4ERR_NOSPC", failmsg=fmsg)
                else:
                    self.test(False, "WRITE to non-allocated file should be sent")
        except Exception:
            self.test(False, traceback.format_exc())
        finally:
            self.pktt.close()

    def alloc06_test(self):
        """Verify ALLOCATE reserves the disk space"""
        self.test_group("Verify ALLOCATE reserves the disk space")
        self.testidx = 1
        self.alloc06()

        if hasattr(self, "deleg_stateid") and self.deleg_stateid is None:
            # Run tests with byte range locking
            msg = " (locking file)"
            self.alloc06(msg=msg, lock=True)

    def dealloc01_test(self):
        """Verify DEALLOCATE succeeds on files opened as write only"""
        self.test_group("Verify DEALLOCATE succeeds on files opened as write only")
        blocksize = self.statvfs.f_bsize
        self.testidx = 1

        self.alloc01(os.O_WRONLY, dealloc=True)
        msg1 = " for a range not starting at the beginning of the file"
        self.alloc01(os.O_WRONLY, offset=blocksize, size=self.filesize, msg=msg1, dealloc=True)
        msg2 = " for a range starting at a non-aligned block size boundary"
        self.alloc01(os.O_WRONLY, offset=blocksize/2, size=blocksize+blocksize/2, msg=msg2, dealloc=True)
        msg3 = " for a range ending at a non-aligned block size boundary"
        self.alloc01(os.O_WRONLY, offset=0, size=blocksize+blocksize/2, msg=msg3, dealloc=True)
        msg4 = " for a range starting and ending at a non-aligned block size boundary"
        self.alloc01(os.O_WRONLY, offset=blocksize/2, size=blocksize, msg=msg4, dealloc=True)
        msg5 = " when range is fully inside the current file size"
        self.alloc01(os.O_WRONLY, offset=self.filesize/4, size=self.filesize/2, msg=msg5, dealloc=True)
        msg6 = " when range is partially outside the current file size"
        self.alloc01(os.O_WRONLY, offset=self.filesize/2, size=self.filesize, msg=msg6, dealloc=True)
        msg7 = " when range is fully outside the current file size"
        self.alloc01(os.O_WRONLY, offset=self.filesize, size=self.filesize, msg=msg7, dealloc=True)

        if hasattr(self, "deleg_stateid") and self.deleg_stateid is None:
            # Run tests with byte range locking
            msg = " (locking file)"
            self.alloc01(os.O_WRONLY, msg=msg, lock=True, dealloc=True)
            self.alloc01(os.O_WRONLY, offset=blocksize, size=self.filesize, msg=msg1+msg, lock=True, dealloc=True)
            self.alloc01(os.O_WRONLY, offset=blocksize/2, size=blocksize+blocksize/2, msg=msg2+msg, lock=True, dealloc=True)
            self.alloc01(os.O_WRONLY, offset=0, size=blocksize+blocksize/2, msg=msg3+msg, lock=True, dealloc=True)
            self.alloc01(os.O_WRONLY, offset=blocksize/2, size=blocksize, msg=msg4+msg, lock=True, dealloc=True)
            self.alloc01(os.O_WRONLY, offset=self.filesize/4, size=self.filesize/2, msg=msg5+msg, lock=True, dealloc=True)
            self.alloc01(os.O_WRONLY, offset=self.filesize/2, size=self.filesize, msg=msg6+msg, lock=True, dealloc=True)
            self.alloc01(os.O_WRONLY, offset=self.filesize, size=self.filesize, msg=msg7+msg, lock=True, dealloc=True)

    def dealloc02_test(self):
        """Verify DEALLOCATE succeeds on files opened as read and write"""
        self.test_group("Verify DEALLOCATE succeeds on files opened as read and write")
        blocksize = self.statvfs.f_bsize
        self.testidx = 1

        self.alloc01(os.O_RDWR, dealloc=True)
        msg1 = " for a range not starting at the beginning of the file"
        self.alloc01(os.O_RDWR, offset=blocksize, size=self.filesize, msg=msg1, dealloc=True)
        msg2 = " for a range starting at a non-aligned block size boundary"
        self.alloc01(os.O_RDWR, offset=blocksize/2, size=blocksize+blocksize/2, msg=msg2, dealloc=True)
        msg3 = " for a range ending at a non-aligned block size boundary"
        self.alloc01(os.O_RDWR, offset=0, size=blocksize+blocksize/2, msg=msg3, dealloc=True)
        msg4 = " for a range starting and ending at a non-aligned block size boundary"
        self.alloc01(os.O_RDWR, offset=blocksize/2, size=blocksize, msg=msg4, dealloc=True)
        msg5 = " when range is fully inside the current file size"
        self.alloc01(os.O_RDWR, offset=self.filesize/4, size=self.filesize/2, msg=msg5, dealloc=True)
        msg6 = " when range is partially outside the current file size"
        self.alloc01(os.O_RDWR, offset=self.filesize/2, size=self.filesize, msg=msg6, dealloc=True)
        msg7 = " when range is fully outside the current file size"
        self.alloc01(os.O_RDWR, offset=self.filesize, size=self.filesize, msg=msg7, dealloc=True)

        if hasattr(self, "deleg_stateid") and self.deleg_stateid is None:
            # Run tests with byte range locking
            msg = " (locking file)"
            self.alloc01(os.O_RDWR, msg=msg, lock=True, dealloc=True)
            self.alloc01(os.O_RDWR, offset=blocksize, size=self.filesize, msg=msg1+msg, lock=True, dealloc=True)
            self.alloc01(os.O_RDWR, offset=blocksize/2, size=blocksize+blocksize/2, msg=msg2+msg, lock=True, dealloc=True)
            self.alloc01(os.O_RDWR, offset=0, size=blocksize+blocksize/2, msg=msg3+msg, lock=True, dealloc=True)
            self.alloc01(os.O_RDWR, offset=blocksize/2, size=blocksize, msg=msg4+msg, lock=True, dealloc=True)
            self.alloc01(os.O_RDWR, offset=self.filesize/4, size=self.filesize/2, msg=msg5+msg, lock=True, dealloc=True)
            self.alloc01(os.O_RDWR, offset=self.filesize/2, size=self.filesize, msg=msg6+msg, lock=True, dealloc=True)
            self.alloc01(os.O_RDWR, offset=self.filesize, size=self.filesize, msg=msg7+msg, lock=True, dealloc=True)

    def dealloc03_test(self):
        """Verify DEALLOCATE fails on files opened as read only"""
        self.test_group("Verify DEALLOCATE fails on files opened as read only")
        self.alloc03(dealloc=True)

    def dealloc04_test(self):
        """Verify DEALLOCATE fails with EINVAL for invalid offset or length"""
        self.test_group("Verify DEALLOCATE fails EINVAL for invalid offset or length")
        self.alloc04(dealloc=True)

    def dealloc05_test(self):
        """Verify DEALLOCATE fails with ESPIPE when using a named pipe file handle"""
        self.test_group("Verify DEALLOCATE fails ESPIPE when using a named pipe file handle")
        self.alloc05(dealloc=True)

    def dealloc06(self, msg="", lock=False):
        """Verify DEALLOCATE unreserves the disk space

           msg:
               String to identify the specific test running and it is appended
               to the main assertion message [default: ""]
           lock:
               Lock file before doing the allocate/deallocate [default: False]
        """
        try:
            fd = None
            testfile = None
            free_space = self.free_blocks * self.statvfs.f_bsize

            self.test_info("====  %s test %02d%s" % (self.testname, self.testidx, msg))
            self.testidx += 1

            self.umount()
            self.trace_start()
            self.mount()
            self.dprint('DBG5', "Available disk space %s" % formatstr.str_units(self.get_freebytes()))

            # Get a new file name
            self.get_filename()
            filename = self.filename
            testfile = self.absfile
            self.dprint('DBG3', "Open file %s for writing" % testfile)
            fd = os.open(testfile, os.O_WRONLY|os.O_CREAT)

            maxsize = self.get_freebytes() - free_space
            tmsg = "when allocating the maximum number of blocks left on the device"
            dmsg = "Allocate file %s with length of %s (available disk space minus %s) " % \
                   (testfile, formatstr.str_units(maxsize), formatstr.str_units(free_space))
            out = self.verify_fallocate(fd, 0, maxsize, absfile=testfile, msg=tmsg, dmsg=dmsg)
            if out == -1: return
            self.dprint('DBG5', "Available disk space %s" % formatstr.str_units(self.get_freebytes()))

            # Check if space was actually allocated
            if self.get_freebytes() > free_space:
                self.test(False, "Space was not actually allocated -- skipping rest of the test")
                return

            # Use the rest of the remaining space and a little bit more
            filesize = 2*self.get_freebytes() + self.filesize

            # Try creating a file to make sure there is no more disk space
            try:
                fmsg = ", expecting ENOSPC but it succeeded"
                werrno = 0
                self.create_file(size=filesize)
            except OSError as werror:
                werrno = werror.errno
                fmsg = ", expecting ENOSPC but got %s" % errno.errorcode.get(werrno, werrno)
            expr = werrno == errno.ENOSPC
            self.test(expr, "Write to a different file should fail with ENOSPC when no space is left on the device", failmsg=fmsg)
            self.dprint('DBG5', "Available disk space %s" % formatstr.str_units(self.get_freebytes()))

            offset = 0
            size = 4*self.filesize
            # Free space after deallocate
            free_space = size - offset
            strsize = formatstr.str_units(size)

            if lock:
                self.dprint('DBG3', "Lock file %s starting at offset %d with length %d" % (testfile, offset, size))
                out = getlock(fd, F_WRLCK, offset, size)

            tmsg = "when no space is left on the device"
            self.verify_fallocate(fd, offset, size, absfile=testfile, msg=tmsg, dealloc=True)
            self.dprint('DBG5', "Available disk space %s" % formatstr.str_units(self.get_freebytes()))

            try:
                fmsg = ""
                werrno = 0
                os.lseek(fd, offset, 0)
                data = self.data_pattern(offset, self.filesize)
                self.dprint('DBG3', "Write file %s %d@%d" % (testfile, len(data), offset))
                count = os.write(fd, data)
                os.fsync(fd)
            except OSError as werror:
                werrno = werror.errno
                fmsg = ", got error [%s] %s" % (errno.errorcode.get(werrno, werrno), os.strerror(werrno))
            self.test(werrno == 0, "Write within the deallocated region should succeed", failmsg=fmsg)
            self.dprint('DBG5', "Available disk space %s" % formatstr.str_units(self.get_freebytes()))

            try:
                fmsg = ""
                werrno = 0
                self.create_file()
            except OSError as werror:
                werrno = werror.errno
                fmsg = ", got error [%s] %s" % (errno.errorcode.get(werrno, werrno), os.strerror(werrno))
            self.test(werrno == 0, "Write to another file should succeed when no space is left on the device after a successful DEALLOCATE"+msg, failmsg=fmsg)
            self.dprint('DBG5', "Available disk space %s" % formatstr.str_units(self.get_freebytes()))

            try:
                fmsg = ", expecting ENOSPC but it succeeded"
                werrno = 0
                os.lseek(fd, offset+self.filesize, 0)
                data = self.data_pattern(offset+self.filesize, size)
                self.dprint('DBG3', "Write file %s %d@%d" % (testfile, len(data), offset+self.filesize))
                count = os.write(fd, data)
                os.fsync(fd)
            except OSError as werror:
                werrno = werror.errno
                fmsg = ", expecting ENOSPC but got %s" % errno.errorcode.get(werrno, werrno)
            expr = werrno == errno.ENOSPC
            self.test(expr, "Write within the deallocated region should fail with ENOSPC when no space is left on the device", failmsg=fmsg)
            self.dprint('DBG5', "Available disk space %s" % formatstr.str_units(self.get_freebytes()))
        except Exception:
            self.test(False, traceback.format_exc())
        finally:
            if fd:
                try:
                    os.close(fd)
                except:
                    pass
            if testfile:
                os.unlink(testfile)
            self.umount()
            self.trace_stop()

        try:
            self.set_nfserr_list(nfs4list=[NFS4ERR_NOENT, NFS4ERR_NOSPC])
            self.trace_open()
            self.set_pktlist()
            # Find OPEN and correct stateid to use
            self.get_stateid(filename)
            stateid = self.open_stateid if self.deleg_stateid is None else self.deleg_stateid

            # Verify ALLOCATE which allocates the rest of the disk space
            self.verify_allocate(0, maxsize, stateid=stateid)

            # Verify DEALLOCATE for file
            self.verify_allocate(offset, size, dealloc=True)

            in_dealloc  = True
            out_dealloc = False
            non_dealloc = False
            in_dealloc_cnt  = 0
            out_dealloc_cnt = 0
            non_dealloc_cnt = 0
            save_index = self.pktt.get_index()
            while True:
                self.pktt.rewind(save_index)
                (pktcall, pktreply) = self.find_nfs_op(OP_WRITE, status=None)
                if not pktcall:
                    break
                save_index = pktcall.record.index + 1
                writeobj = pktcall.NFSop
                free_space -= writeobj.count
                if writeobj.stateid == self.stateid:
                    # WRITE sent to deallocated file
                    if writeobj.offset < offset+self.filesize:
                        # WRITE sent to deallocated region when space is available
                        in_dealloc_cnt += 1
                        if pktreply.nfs.status != NFS4_OK:
                            in_dealloc = False
                    else:
                        # WRITE sent to deallocated region when space is no longer available
                        out_dealloc_cnt += 1
                        if pktreply.nfs.status == NFS4ERR_NOSPC:
                            out_dealloc = True
                else:
                    # WRITE sent to different file
                    non_dealloc_cnt += 1
                    if pktreply.nfs.status == NFS4_OK:
                        non_dealloc = True
            if in_dealloc_cnt > 0:
                self.test(in_dealloc, "WRITE within the deallocated region should succeed")
            else:
                self.test(False, "WRITE within the deallocated region should be sent")
            if non_dealloc_cnt > 0:
                self.test(non_dealloc, "WRITE sent to another file should succeed when no space is left on the device after a successful DEALLOCATE")
            else:
                self.test(False, "WRITE should be sent to another file when no space is left on the device after a successful DEALLOCATE")
            if out_dealloc_cnt > 0:
                self.test(out_dealloc, "WRITE within the deallocated region should fail with NFS4ERR_NOSPC when no space is left on the device")
            else:
                self.test(False, "WRITE within the deallocated region should be sent")
        except Exception:
            self.test(False, traceback.format_exc())
        finally:
            self.pktt.close()

    def dealloc06_test(self):
        """Verify DEALLOCATE unreserves the disk space"""
        self.test_group("Verify DEALLOCATE unreserves the disk space")
        self.testidx = 1
        self.dealloc06()

        if hasattr(self, "deleg_stateid") and self.deleg_stateid is None:
            # Run tests with byte range locking
            msg = " (locking file)"
            self.dealloc06(msg=msg, lock=True)

    def perftest(self, filesize):
        try:
            fd = None
            block_size = 16 * self.statvfs.f_bsize
            strsize = formatstr.str_units(filesize)
            filelist = []

            # Get a new file name
            self.get_filename()
            filelist.append(self.absfile)
            self.dprint('DBG3', "Open file %s for writing" % self.absfile)
            fd = os.open(self.absfile, os.O_WRONLY|os.O_CREAT)

            tstart = time.time()
            tmsg = "when the file is opened as write only"
            out = self.verify_fallocate(fd, 0, filesize, msg=tmsg)
            os.close(fd)
            fd = None
            t1delta = time.time() - tstart
            self.dprint('INFO', "ALLOCATE took %f seconds" % t1delta)

            # Get a new file name
            self.get_filename()
            filelist.append(self.absfile)
            self.dprint('DBG3', "Open file %s for writing" % self.absfile)
            fd = os.open(self.absfile, os.O_WRONLY|os.O_CREAT)
            self.dprint('DBG3', "Initialize file %s with zeros" % self.absfile)
            size = filesize
            data = "\x00" * block_size
            tstart = time.time()
            while size > 0:
                if block_size > size:
                    data = data[:size]
                count = os.write(fd, data)
                size -= count
            os.close(fd)
            fd = None
            t2delta = time.time() - tstart
            fstat = os.stat(self.absfile)
            self.test(fstat.st_size == filesize, "File size should be correct after initialization")
            self.dprint('INFO', "Initialization took %f seconds" % t2delta)
            if t1delta > 0:
                perf = int(100.0*(t2delta-t1delta) / t1delta)
                msg = ", performance improvement for a %s file: %s%%" % (strsize, "{:,}".format(perf))
            else:
                msg = ""
            self.test(t1delta < t2delta, "ALLOCATE should outperform initializing the file to all zeros" + msg)

        except Exception:
            self.test(False, traceback.format_exc())
        finally:
            if fd:
                os.close(fd)
            for absfile in filelist:
                try:
                    if os.path.exists(absfile):
                        self.dprint('DBG5', "Removing file %s" % absfile)
                        os.unlink(absfile)
                except:
                    pass

    def perf01_test(self):
        """Verify ALLOCATE outperforms initializing the file to all zeros"""
        self.test_group("Verify ALLOCATE outperforms initializing the file to all zeros")
        # Starting file size
        filesize = self.perf_fsize
        self.umount()
        self.mount()
        self.testidx = 1
        while True:
            self.test_info("====  %s test %02d" % (self.testname, self.testidx))
            self.testidx += 1
            tstart = time.time()
            self.perftest(filesize)
            tdelta = time.time() - tstart
            if tdelta > self.perf_time:
                break
            filesize = self.perf_mult*filesize
        self.umount()

################################################################################
# Entry point
x = AllocTest(usage=USAGE, testnames=TESTNAMES, testgroups=TESTGROUPS, sid=SCRIPT_ID)

try:
    x.setup(nfiles=1)

    # Run all the tests
    x.run_tests()
except Exception:
    x.test(False, traceback.format_exc())
finally:
    x.cleanup()
    x.exit()
