#!/usr/bin/env python
#===============================================================================
# Copyright 2012 NetApp, Inc. All Rights Reserved,
# contribution by Jorge Mora <mora@netapp.com>
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#===============================================================================
import os
import errno
import fcntl
import struct
import traceback
import nfstest_config as c
from packet.nfs.nfs4_const import *
from nfstest.test_util import TestUtil

# Module constants
__author__    = "Jorge Mora (%s)" % c.NFSTEST_AUTHOR_EMAIL
__copyright__ = "Copyright (C) 2012 NetApp, Inc."
__license__   = "GPL v2"
__version__   = "1.5"

USAGE = """%prog --server <server> [--client <client>] [options]

Delegation tests
================
Basic delegation tests verify that a correct delegation is granted when
opening a file for reading or writing. Also, another OPEN should not be
sent for the same file when the client is holding a delegation. Verify
that the stateid of all I/O operations should be the delegation stateid.
Reads from a different process on the same file should not cause the client
to send additional READ packets when the client is holding a read delegation.
Furthermore, a LOCK packet should not be sent to the server when the client
is holding a delegation.

Recall delegation tests verify the delegation is recalled when a conflicting
operation is sent to the server from a different client. Conflicting operations
are reading, writing and changing the permissions on the same file. Note, that
reading a file from a different client can only recall a read delegation.
Also, verify that a delegation is not recalled when a different client is
granted a read delegation. After a delegation is recalled, the client should
send an OPEN with CLAIM_DELEGATE_CUR before returning the delegation and the
stateid should be the same as the original OPEN stateid. Also, a delegation
should not be granted when re-opening the file right before returning
the delegation. Verify client flushes all written data before returning
the WRITE delegation. The LOCK should be sent as well right before returning
a delegation which has been recalled. A delegation should not be granted
on the second client who cause the delegation recall on the first client.

Examples:
    The only required option is --server but only the basic delegation tests
    will be run. Use the --client option to run the recall tests as well
    $ %prog --server 192.168.0.11 --client 192.168.0.20

Notes:
    The user id in the local host and the host specified by --client must
    have access to run commands as root using the 'sudo' command without
    the need for a password.

    The user id must be able to 'ssh' to remote host without the need for
    a password."""

# Test script ID
SCRIPT_ID = "DELEGATION"

TESTNAMES_LOCAL = [
    "basic01",
    "basic02",
    "basic03",
    "basic04",
    "basic05",
    "basic06",
]
TESTNAMES_SETATTR = [
    "recall07",
    "recall08",
    "recall09",
    "recall10",
]
TESTNAMES_REMOVE = [
    "recall11",
    "recall12",
    "recall13",
    "recall14",
]
TESTNAMES_RENAME = [
    "recall15",
    "recall16",
    "recall17",
    "recall18",
    "recall19",
    "recall20",
    "recall21",
    "recall22",
]
TESTNAMES_REMOTE = [
    "recall01",
    "recall02",
    "recall03",
    "recall04",
    "recall05",
    "recall06",
] + TESTNAMES_SETATTR + TESTNAMES_REMOVE + TESTNAMES_RENAME

# Include the test groups in the list of test names
# so they are displayed in the help
GTESTS = ["recall", "setattr", "remove", "rename"]
TESTNAMES = ["basic"] + TESTNAMES_LOCAL + GTESTS + TESTNAMES_REMOTE

TESTGROUPS = {
    "basic": {
         "tests": TESTNAMES_LOCAL,
         "desc": "Run all basic delegation tests: ",
    },
    "recall": {
         "tests": TESTNAMES_REMOTE,
         "desc": "Run all recall delegation tests: ",
    },
    "setattr": {
         "tests": TESTNAMES_SETATTR,
         "desc": "Run all tests using SETATTR to recall the delegation: ",
    },
    "remove": {
         "tests": TESTNAMES_REMOVE,
         "desc": "Run all tests recalling the delegation by removing the delegated file: ",
    },
    "rename": {
         "tests": TESTNAMES_RENAME,
         "desc": "Run all tests recalling the delegation by renaming the delegated file: ",
    },
}

PATTERN = 'FF00'

OPEN_STID  = 0
LOCK_STID  = 1
DELEG_STID = 2
stid_map = {
    OPEN_STID  : "OPEN",
    LOCK_STID  : "LOCK",
    DELEG_STID : "DELEG",
}

def open_mode(deleg_type):
    """Open mode according to delegation type."""
    if deleg_type == OPEN_DELEGATE_READ:
        return os.O_RDONLY
    else:
        return os.O_WRONLY|os.O_CREAT

def open_mode_str(deleg_type):
    """String representation for open mode according to delegation type."""
    if deleg_type == OPEN_DELEGATE_READ:
        return 'READ'
    else:
        return 'WRITE'

class BaseName(Exception):
    """Exception used to stop recall tests when --basename option is set"""
    pass

class DelegTest(TestUtil):
    """DelegTest object

       DelegTest() -> New test object

       Usage:
           x = DelegTest(testnames=['basic', 'basic_lock', ...])

           # Run all the tests
           x.run_tests(deleg=deleg_mode)
           x.exit()
    """
    def __init__(self, **kwargs):
        """Constructor

           Initialize object's private data.
        """
        TestUtil.__init__(self, **kwargs)
        self.test_opgroup.version = "%prog " + __version__
        hhelp = "Remote NFS client used for recall tests"
        self.test_opgroup.add_option("--client", default=None, help=hhelp)
        hhelp = "Starting offset for lock [default: %default]"
        self.test_opgroup.add_option("--lock-offset", type="int", default=0, help=hhelp)
        hhelp = "Number of bytes to lock [default: %default]"
        self.test_opgroup.add_option("--lock-len", type="int", default=0, help=hhelp)
        hhelp = "Truncate file when writing from the second file for the recall tests"
        self.test_opgroup.add_option("--truncate", action="store_true", default=False, help=hhelp)
        self.scan_options()

        # Disable createtraces option
        self.createtraces = False

        # Check if remote server needs to run
        isremote = False
        for tname in TESTNAMES_REMOTE:
            if tname in self.testlist:
                isremote = True
                break

        # Local rexec object
        self.lexecobj = None

        if self.client is not None and isremote:
            self.create_host(self.client)
            self.create_rexec(self.client)
        else:
            self.clientobj = None

        if self.clientobj is None:
            # No --client was specified, so remove all tests that require
            # a second client from the list of tests to run
            for tname in TESTNAMES_REMOTE:
                if tname in self.testlist:
                    self.testlist.remove(tname)
            if len(self.testlist) == 0:
                self.opts.error("no test to run, specify option --client for --runtest='%s'" % self.runtest)

    def lock_file(self, fd, lock_type, absfile):
        """Lock file given by the file descriptor.

           fd:
               Opened file descriptor of file
           lock_type:
               Lock type
           absfile:
               File path to display as debug info
        """
        lock_type = fcntl.F_RDLCK if lock_type == OPEN_DELEGATE_READ else fcntl.F_WRLCK
        lock_str = "F_RDLCK" if lock_type == OPEN_DELEGATE_READ else "F_WRLCK"
        try:
            fmsg = ""
            self.dprint('DBG3', "Lock %s (F_SETLKW, %s) start=%d len=%d" % (absfile, lock_str, self.lock_offset, self.lock_len))
            lockdata = struct.pack('hhllhh', lock_type, 0, self.lock_offset, self.lock_len, 0, 0)
            rv = fcntl.fcntl(fd, fcntl.F_SETLKW, lockdata)
        except OSError as exerr:
            fmsg = ", failed with %s" % exerr
        dmsg = "Lock file with %s" % lock_str
        self.test(len(fmsg) == 0, "%s should succeed" % dmsg, failmsg=fmsg)

    def open_file(self, absfile, deleg_type, lock=False, lexec=False, msg=''):
        """Open file, lock it and do some I/O on the file.
           Return the file descriptor of the opened file.

           absfile:
               File name to open
           deleg_type:
               Delegation type to get
           lock:
               Get a lock on the file if true [default: False]
           lexec:
               Use different process to open file [default: False]
           msg:
               Message to append on debug message [default: '']
        """
        pidstr = " from a different process" if lexec else ""
        msg = msg if len(msg) == 0 else " %s" % msg
        mode_str = open_mode_str(deleg_type)

        try:
            fmsg = ""
            dmsg = "Open file for %s%s%s" % (mode_str, pidstr, msg)
            self.dprint('DBG2', "%s [%s]" % (dmsg, absfile))
            if lexec:
                fd = self.lexecobj.run(os.open, absfile, open_mode(deleg_type))
            else:
                fd = os.open(absfile, open_mode(deleg_type))
        except OSError as exerr:
            fmsg = ", failed with %s" % exerr
        self.test(len(fmsg) == 0, "%s should succeed" % dmsg, failmsg=fmsg)

        if lock:
            self.lock_file(fd, deleg_type, absfile)

        try:
            fmsg = ""
            dmsg = "%s file%s%s" % (mode_str.capitalize(), pidstr, msg)
            self.dprint("DBG3", "%s [%s]" % (dmsg, absfile))
            # Read/Write file
            if deleg_type == OPEN_DELEGATE_READ:
                if lexec:
                    self.lexecobj.run(os.read, fd, self.rsize)
                else:
                    os.read(fd, self.rsize)
            else:
                data = self.data_pattern(0, self.wsize, PATTERN)
                if lexec:
                    self.lexecobj.run(os.write, fd, data)
                else:
                    os.write(fd, data)
        except OSError as exerr:
            fmsg = ", failed with %s" % exerr
        self.test(len(fmsg) == 0, "%s should succeed" % dmsg, failmsg=fmsg)

        self.delay_io()
        return fd

    def get_deleg_remote(self):
        """Get a read delegation on the remote client."""
        fdko = self.rexecobj.run(os.open, self.abspath(self.files[0]), os.O_RDONLY)
        self.dprint("DBG2", "Get a read delegation on the remote client [%s]" % self.absfile)
        fdrd = self.rexecobj.run(os.open, self.absfile, os.O_RDONLY)
        self.dprint("DBG3", "Read %s on the remote client" % self.absfile)
        data = self.rexecobj.run(os.read, fdrd, 1024)
        self.dprint("DBG4", "Close %s on the remote client" % self.absfile)
        self.rexecobj.run(os.close, fdrd)
        self.rexecobj.run(os.close, fdko)

    def setup_test(self, deleg_type, mount=False, nfiles=0, lexec=False):
        """Setup test by mounting server and hold open a file so that the open
           owner sticks around so a delegation is granted on next open using
           the same open owner -- this is done to avoid a bug on the client
           where open owner is reaped at close
        """
        if nfiles > 0:
            self.umount()
            self.mount()
            # Create new files before starting the test
            for i in range(nfiles):
                self.create_file()

        self.umount()
        if mount and self.clientobj is not None:
            # Unmount server on remote client
            self.clientobj.umount()

        if lexec and self.lexecobj is None:
            # Start local rexec connection just once
            rexecobj_save = self.rexecobj
            self.lexecobj = self.create_rexec()
            self.rexecobj = rexecobj_save

        self.trace_start()
        self.mount()
        if mount and self.clientobj is not None:
            # Mount server on remote client
            self.clientobj.mount()

        if nfiles == 0:
            if deleg_type == OPEN_DELEGATE_READ:
                # Use existing file
                self.filename = self.files[1]
                self.absfile = self.abspath(self.filename)
            else:
                # Create new file
                self.get_filename()

        # Hold a file open so that the open owner sticks around
        # (bug on the client where OO's are reaped at close)
        self.dprint('DBG4', "Open %s so open owner sticks around" % self.abspath(self.files[0]))
        self.fdko = open(self.abspath(self.files[0]), 'r')

    def verify_io_requests(self, iomode, deleg_stid, filehandles, src_ipaddr=None, maxindex=None):
        """Verify I/O is sent to the correct server."""
        nio = 0
        dsindex = 0
        for fh in filehandles:
            if self.dslist:
                # The address is one of the DS's connection
                ds = self.dslist[dsindex]
            else:
                # The address is the mounted server
                ds = [{"ipaddr": self.server_ipaddr, "port": self.port}]
            for item in ds:
                save_index = self.pktt.get_index()
                nio += self.verify_io(iomode, deleg_stid, item["ipaddr"], item["port"], filehandle=fh, src_ipaddr=src_ipaddr, maxindex=maxindex, pattern=PATTERN)
                self.pktt.rewind(save_index)
            dsindex += 1
        return nio

    def verify_open(self, fh, stat=False):
        """Verify OPEN call"""
        if self.opencall is None:
            return
        self.test(fh, "OPEN should be sent")
        if stat:
            expr = self.opencall.NFSop.claim.claim == CLAIM_FH
            self.test(expr, "OPEN should be sent with CLAIM_FH")
            expr = self.opencall.NFSop.fh == fh
            self.test(expr, "OPEN should be sent with the filehandle of the file to be opened")
        else:
            expr = self.opencall.NFSop.claim.claim == CLAIM_NULL
            self.test(expr, "OPEN should be sent with CLAIM_NULL")
            if expr:
                expr = self.opencall.NFSop.claim.name == self.filename
                self.test(expr, "OPEN should be sent with the name of the file to be opened")
            expr = self.opencall.NFSop.fh != fh
            self.test(expr, "OPEN should be sent with the filehandle of the directory")

    def find_ios(self, op_type, filehandle, ipaddr, port):
        """Return a list of all I/O packets"""
        ret = {}
        # Matched all packets sent to the server given by ipaddr and port
        src = "IP.src == '%s' and " % self.client_ipaddr
        dst = self.pktt.ip_tcp_dst_expr(ipaddr, port)
        fh  = " and NFS.fh == '%s' and " % self.pktt.escape(filehandle)
        matchstr = src + dst + fh + "NFS.argop == %d" % op_type

        save_index = self.pktt.get_index()
        self.pktt.clear_xid_list()
        try:
            # Matched all I/O packets and their replies
            while self.pktt.match(matchstr, reply=True):
                pkt = self.pktt.pkt
                xid = pkt.rpc.xid
                if pkt.rpc.type == 0:
                    # Save I/O call info
                    nfsop = pkt.NFSop
                    info = {
                        "stateid": nfsop.stateid,
                        "count":   nfsop.count,
                        "nfsidx":  pkt.NFSidx,
                        "callidx": pkt.record.index,
                    }
                    if ret.get(xid) is None:
                        ret[xid] = info
                    else:
                        ret[xid].update(info)
                else:
                    # Save I/O reply status
                    idx = ret[xid].get("nfsidx")
                    if idx is not None and len(pkt.nfs.array) > idx:
                        nfsop = pkt.nfs.array[idx]
                        ret[xid]["status"] = nfsop.status
        except:
            self.test(False, traceback.format_exc())
        finally:
            self.pktt.rewind(save_index)
        # Return the list of I/O packets having status values
        return [item for item in ret.values() if item.get("status") is not None]

    def find_io_counts(self, io_list, stateid, status):
        """Return the number of matched stateid and matched status packets"""
        stid = 0  # Number of I/O packets matching the stateid
        stat = 0  # Number of I/O packets matching the status
        okct = 0  # Number of I/O packets with status = NFS4_OK
        for item in io_list:
            istatus = item.get('status')
            if istatus is None:
                continue
            if item.get('stateid') == stateid:
                stid += 1
            if istatus == status:
                stat += 1
            if istatus == NFS4_OK:
                okct += 1
        return (stid, stat, okct)

    def verify_io_per_server(self, io_list, op_type, stid_type, stateid, status, ds=False, delegret=False):
        """Verify I/O packets for a given server"""
        dr_str = " after returning the delegation" if delegret else ""
        io_str = "READ" if op_type == OP_READ else "WRITE"
        st_str = stid_map.get(stid_type)
        sv_str = "server"
        if self.layout and self.dslist:
            sv_str = "DS" if ds else "MDS"

        if io_list:
            nlen = len(io_list)
            (stid, stat, okct) = self.find_io_counts(io_list, stateid, status[0])
            self.test(stid == nlen, "%ss should be sent to the %s with the %s stateid%s" % (io_str, sv_str, st_str, dr_str))
            if delegret and okct == nlen and stat == 0:
                # The RFC allows servers to process I/O operations successfully
                # when the file has been removed. In this case all I/O operations
                # have succeeded but an error was expected for those servers
                # failing I/O operations when the file is removed.
                self.test(True, "%ss may return NFS4_OK from the %s%s" % (io_str, sv_str, dr_str))
            else:
                # Check if all I/O operations returned one of the expected
                # status codes
                idx = 0
                if stat != nlen:
                    for i in range(1, len(status)):
                        (stid, stat, okct) = self.find_io_counts(io_list, stateid, status[i])
                        if stat == nlen:
                            idx = i
                            break
                self.test(stat == nlen, "%ss should return %s from the %s%s" % (io_str, nfsstat4.get(status[idx], status[idx]), sv_str, dr_str))

    def verify_io_packets(self, deleg_type, open_fh, stid_type, stateid, status=[NFS4_OK], ds_status=[NFS4_OK], delegret=False):
        """Verify I/O packets"""
        io_list = []
        op_type =  OP_READ if deleg_type == OPEN_DELEGATE_READ else OP_WRITE
        if self.layout and self.dslist:
            # Get I/O packets sent to the DS
            dsindex = 0
            for fh in self.layout['filehandles']:
                for item in self.dslist[dsindex]:
                    if item is not None:
                        io_list += self.find_ios(op_type, fh, item['ipaddr'], item['port'])
                dsindex += 1
        # Verify I/O packets sent to the DS
        self.verify_io_per_server(io_list, op_type, stid_type, stateid, ds_status, ds=True, delegret=delegret)

        # Verify I/O packets sent to the server (or MDS if pNFS is available)
        io_list = self.find_ios(op_type, open_fh, self.server_ipaddr, self.port)
        self.verify_io_per_server(io_list, op_type, stid_type, stateid, status, delegret=delegret)

    def basic_deleg_test(self, deleg_type, lock=False, stat=False, nfiles=0):
        """Basic delegation tests"""
        try:
            fds = []
            self.fdko = None
            mode_str = open_mode_str(deleg_type)
            if lock:
                extra_str = " with file lock"
            elif stat:
                extra_str = " with file stat"
            else:
                extra_str = ""
            self.test_group("Basic %s delegation test%s" % (mode_str, extra_str))
            self.setup_test(deleg_type, nfiles=nfiles, lexec=True)

            if stat:
                try:
                    fmsg = ""
                    dmsg = "Stat file to cache file metadata"
                    self.dprint('DBG3', "%s [%s]" % (dmsg, self.absfile))
                    fstat = os.stat(self.absfile)
                except OSError as exerr:
                    fmsg = ", failed with %s" % exerr
                self.test(len(fmsg) == 0, "%s should succeed" % dmsg, failmsg=fmsg)

            # Open file, should get a DELEGATION
            fds.append(self.open_file(self.absfile, deleg_type, lock=lock))

            # Open same file on same process for reading
            fds.append(self.open_file(self.absfile, OPEN_DELEGATE_READ, msg="on same process"))

            if deleg_type == OPEN_DELEGATE_WRITE:
                # Open same file on same process for writing
                fds.append(self.open_file(self.absfile, deleg_type, msg="on same process"))

            # Access file from a different process
            fd = self.open_file(self.absfile, OPEN_DELEGATE_READ, lexec=True)
            self.lexecobj.run(os.close, fd)

            if deleg_type == OPEN_DELEGATE_WRITE:
                # Open same file on different process for writing
                fd = self.open_file(self.absfile, deleg_type, lexec=True)
                self.lexecobj.run(os.close, fd)
        except Exception:
            self.test(False, traceback.format_exc())
            return
        finally:
            if self.fdko:
                # Close open owner file
                self.fdko.close()
            # Close open files
            for fd in fds:
                os.close(fd)
            self.umount()
            self.trace_stop()

        try:
            self.trace_open()
            self.set_pktlist()

            filehandle = None
            if stat:
                # Find the LOOKUP for the file under test
                while True:
                    (lookupcall, lookupreply) = self.find_nfs_op(OP_LOOKUP, src_ipaddr=self.client_ipaddr)
                    if lookupcall is None or lookupcall.NFSop.name == self.filename:
                        # Found LOOKUP for the filename or the end of the
                        # trace file has been reached
                        break
                self.test(lookupcall, "LOOKUP operation should be sent")
                if lookupreply:
                    # GETFH should be the operation following the LOOKUP
                    getfh_obj = self.getop(lookupreply, OP_GETFH)
                    if getfh_obj:
                        # Get the file handle for the file under test
                        filehandle = getfh_obj.fh
                    else:
                        # Could not find GETFH
                        self.test(False, "Could not find GETFH operation in the LOOKUP compound")

            (fh, op_stid, deleg_stid) = self.find_open(filename=self.filename, claimfh=filehandle, deleg_type=deleg_type, anyclaim=True)
            self.verify_open(fh, stat)
            self.test(deleg_stid != None, "%s delegation should be granted" % mode_str)
            save_index = self.pktt.get_index()
            if deleg_stid is None:
                # Delegation was not granted
                return

            filehandles = [fh]
            self.find_layoutget(fh)
            (devcall, devreply, dslist) = self.find_getdeviceinfo()
            self.pktt.rewind(save_index)
            if self.layout:
                filehandles = self.layout['filehandles']

            # Find any other OPENs for the same file
            olist = self.find_open(filename=self.filename)
            self.test(olist[0] is None, "OPEN should not be sent for the same file")

            if lock:
                # Rewind trace file
                self.pktt.rewind()
                (lockcall, lockreply) = self.find_nfs_op(OP_LOCK, src_ipaddr=self.client_ipaddr)
                self.test(lockcall is None, "LOCK should not be sent to the server")

            # Verify I/O packets
            self.verify_io_packets(deleg_type, fh, DELEG_STID, deleg_stid)

            # Rewind trace file to saved packet index
            if deleg_type == OPEN_DELEGATE_READ:
                self.pktt.rewind(save_index)
                nio = self.verify_io_requests(deleg_type, deleg_stid, filehandles, src_ipaddr=self.client_ipaddr)
                if nio > 0:
                    unique_io_list = sorted(set(self.test_offsets))
                    expr = len(self.test_offsets) == len(unique_io_list)
                    self.test(expr, "%s should not be sent when reading delegated file from a different process" % mode_str)

            # Find CLOSE request and reply
            self.pktt.rewind(save_index)
            match_str = "NFS.fh == '%s'" % self.pktt.escape(fh)
            (closecall, closereply) = self.find_nfs_op(OP_CLOSE, src_ipaddr=self.client_ipaddr, match=match_str)

            if closecall:
                # Find DELEGRETURN request and reply
                self.pktt.rewind(closecall.record.index)
                (delegreturncall, delegreturnreply) = self.find_nfs_op(OP_DELEGRETURN, src_ipaddr=self.client_ipaddr, match=match_str)
                self.test(delegreturncall, "DELEGRETURN should be sent after the close")
                if delegreturncall:
                    expr = delegreturncall.NFSop.stateid.other == deleg_stid
                    self.test(expr, "DELEGRETURN should be sent with the delegation stateid")
        except Exception:
            self.test(False, traceback.format_exc())

    def recall_deleg_test(self, deleg_type, conflict_type=None, lock=False, nfiles=0, target=False):
        """Delegation recall tests"""
        if self.clientobj is None:
            return
        if deleg_type == OPEN_DELEGATE_READ and conflict_type == OPEN_DELEGATE_READ:
            return
        try:
            fd = None
            self.fdko = None
            target_str = ""
            mode_str = open_mode_str(deleg_type)
            if conflict_type is None:
                # Conflict OPEN type for both READ and WRITE
                conflict_type = OPEN_DELEGATE_WRITE
            if conflict_type == OP_SETATTR:
                conflict_str = "SETATTR (chmod)"
                conflict_op = OP_SETATTR
            elif conflict_type == OP_REMOVE:
                conflict_str = "REMOVE"
                conflict_op = OP_REMOVE
            elif conflict_type == OP_RENAME:
                conflict_str = "RENAME"
                conflict_op = OP_RENAME
                target_str = " (DST)" if target else " (SRC)"
            else:
                conflict_str = "OPEN (%s)" % open_mode_str(conflict_type)
                conflict_op = OP_OPEN
            lock_str = " with file lock" if lock else ""
            self.test_group("%s delegation recall test%s -- recall with %s%s" % (mode_str, lock_str, conflict_str, target_str))

            self.setup_test(deleg_type, mount=True, nfiles=nfiles)

            # Open file, should get a DELEGATION
            try:
                fmsg = ""
                dmsg = "Open file for %s" % mode_str
                self.dprint('DBG2', "%s [%s]" % (dmsg, self.absfile))
                fd = os.open(self.absfile, open_mode(deleg_type))
            except OSError as exerr:
                fmsg = ", failed with %s" % exerr
            self.test(len(fmsg) == 0, "%s should succeed" % dmsg, failmsg=fmsg)

            if lock:
                self.lock_file(fd, deleg_type, self.absfile)

            iosize = int(self.PAGESIZE/2)

            if len(self.basename) > 0:
                if conflict_type == OP_RENAME and not target:
                    aname = self.absfile
                    fname = self.filename
                    self.get_filename()
                    self.absfile  = aname
                    self.filename = fname
                raise BaseName

            try:
                # Read/Write file
                fmsg = ""
                dmsg = "%s file on client holding delegation" % mode_str.capitalize()
                self.dprint("DBG3", "%s [%s]" % (dmsg, self.absfile))
                if deleg_type == OPEN_DELEGATE_READ:
                    os.read(fd, iosize)
                else:
                    os.write(fd, self.data_pattern(0, iosize, PATTERN))
            except OSError as exerr:
                fmsg = ", failed with %s" % exerr
            self.test(len(fmsg) == 0, "%s should succeed" % dmsg, failmsg=fmsg)
            self.delay_io()

            # Read same file from another client -- delegation should not be
            # recalled and delegation should be granted
            if deleg_type == OPEN_DELEGATE_READ:
                # Other READ opens will not recall the delegation
                self.get_deleg_remote()

            try:
                fmsg = ""
                if conflict_type == OP_SETATTR:
                    dmsg = "Change permissions on the file from another client"
                    self.dprint("DBG2", "%s to recall delegation [%s]" % (dmsg, self.absfile))
                    self.rexecobj.run(os.chmod, self.absfile, 0777)
                elif conflict_type == OP_REMOVE:
                    dmsg = "Remove the file from another client"
                    self.dprint("DBG2", "%s to recall delegation [%s]" % (dmsg, self.absfile))
                    self.rexecobj.run(os.unlink, self.absfile)
                elif conflict_type == OP_RENAME:
                    if target:
                        fname = self.files[-2]
                        srcname = self.abspath(fname)
                        dmsg = "Rename into the file (DST) from another client"
                        self.dprint("DBG2", "%s to recall delegation [%s -> %s]" % (dmsg, fname, self.filename))
                        self.rexecobj.run(os.rename, srcname, self.absfile)
                    else:
                        aname = self.absfile
                        fname = self.filename
                        self.get_filename()
                        dmsg = "Rename the file (SRC) from another client"
                        self.dprint("DBG2", "%s to recall delegation [%s -> %s]" % (dmsg, fname, self.filename))
                        newname = self.absfile
                        self.absfile  = aname
                        self.filename = fname
                        self.rexecobj.run(os.rename, self.absfile, newname)
                elif conflict_type == OPEN_DELEGATE_READ:
                    dmsg = "Read same file from another client"
                    self.dprint("DBG2", "%s to recall delegation [%s]" % (dmsg, self.absfile))
                    fdrd = self.rexecobj.run(os.open, self.absfile, os.O_RDONLY)
                    data = self.rexecobj.run(os.read, fdrd, 1024)
                    self.rexecobj.run(os.close, fdrd)
                elif self.truncate:
                    dmsg = "Write same file (truncate before writing) from another client"
                    self.dprint("DBG2", "%s to recall delegation [%s]" % (dmsg, self.absfile))
                    fdwr  = self.rexecobj.run(os.open, self.absfile, os.O_WRONLY|os.O_TRUNC)
                    count = self.rexecobj.run(os.write, fdwr, self.data_pattern(0, 1024, "x"))
                    self.rexecobj.run(os.close, fdwr)
                else:
                    dmsg = "Write same file from another client"
                    self.dprint("DBG2", "%s to recall delegation [%s]" % (dmsg, self.absfile))
                    fdwr  = self.rexecobj.run(os.open, self.absfile, os.O_WRONLY|os.O_APPEND)
                    count = self.rexecobj.run(os.write, fdwr, self.data_pattern(0, 1024, "X"))
                    self.rexecobj.run(os.close, fdwr)
            except OSError as exerr:
                fmsg = ", failed with %s" % exerr
            self.test(len(fmsg) == 0, "%s should succeed" % dmsg, failmsg=fmsg)

            try:
                fmsg = ""
                dmsg = "%s file after conflicting operation" % mode_str.capitalize()
                self.dprint("DBG3", "%s [%s]" % (dmsg, self.absfile))
                # Read/Write file
                if deleg_type == OPEN_DELEGATE_READ:
                    # Read should not fail
                    expfail = False
                    os.read(fd, self.filesize - iosize)
                else:
                    # Check for errors on the write since the server may return
                    # an error when the file has been removed by another client
                    expfail = conflict_type == OP_REMOVE or (conflict_type == OP_RENAME and target)
                    os.write(fd, self.data_pattern(iosize, self.filesize - iosize, PATTERN))
                    # Flush data so if there is an error on a write it will
                    # happened here instead on the close
                    os.fdatasync(fd)
            except OSError as exerr:
                if expfail:
                    expected = errno.errorcode[errno.ESTALE]
                    error = errno.errorcode[exerr.errno]
                    fmsg =  ": expecting %s, got %s" % (expected, error)
                    self.dprint("DBG4", "%s returns: %s" % (dmsg, str(exerr)))
                    self.test(exerr.errno == errno.ESTALE, "%s may return an error" % dmsg, failmsg=fmsg)
                else:
                    fmsg = ", failed with %s" % exerr
            if not expfail:
                self.test(len(fmsg) == 0, "%s should succeed" % dmsg, failmsg=fmsg)
            self.delay_io()
        except BaseName:
            pass
        except:
            self.test(False, traceback.format_exc())
        finally:
            if fd:
                # Close file
                self.dprint('DBG4', "Close %s" % self.absfile)
                os.close(fd)
            if self.fdko:
                # Close open owner file
                self.fdko.close()
            self.umount()
            if self.clientobj:
                self.clientobj.umount()
            self.trace_stop()

        try:
            self.trace_open()
            self.set_pktlist()

            (open_fh, open_stid, deleg_stid) = self.find_open(filename=self.filename, deleg_type=deleg_type, src_ipaddr=self.client_ipaddr)
            self.verify_open(open_fh)
            self.test(deleg_stid != None, "%s delegation should be granted" % mode_str)
            save_index = self.pktt.get_index()
            open1_index = save_index
            if deleg_stid is None:
                # Delegation was not granted
                return

            filehandles = [open_fh]
            self.find_layoutget(open_fh)
            (devcall, devreply, dslist) = self.find_getdeviceinfo()
            self.pktt.rewind(save_index)
            if self.layout:
                filehandles = self.layout['filehandles']

            if deleg_type == OPEN_DELEGATE_READ:
                # Find OPEN (READ) call from the second client
                (fh1, op_stid1, deleg_stid1) = self.find_open(filename=self.filename, src_ipaddr=self.clientobj.ipaddr)
                save_index = self.pktt.get_index()

            # Find DELEGRETURN request and reply
            (delegreturncall, delegreturnreply) = self.find_nfs_op(OP_DELEGRETURN, src_ipaddr=self.client_ipaddr)
            if delegreturncall:
                delegreturn_index = delegreturncall.record.index
            self.pktt.rewind(save_index)

            # Find OPEN call from the second client
            src_other_client_str = self.pktt.ip_tcp_dst_expr(self.server_ipaddr, self.port) + " and IP.src == '%s' and " % self.clientobj.ipaddr
            conflict_match_str = src_other_client_str + "NFS.argop == %d" % conflict_op
            if conflict_op == OP_OPEN:
                conflict_match_str += " and (NFS.claim.name == '%s' or" % self.filename
                conflict_match_str += " (NFS.fh == '%s' and NFS.claim.claim == %d))" % (self.pktt.escape(open_fh), CLAIM_FH)
            elif target and conflict_op == OP_RENAME:
                conflict_match_str += " and NFS.newname == '%s'" % self.filename
            elif conflict_op in [OP_REMOVE, OP_RENAME]:
                conflict_match_str += " and NFS.name == '%s'" % self.filename

            openreply = None
            while True:
                opencall = self.pktt.match(conflict_match_str)
                if opencall is None:
                    break

                # Make sure conflicting operation reply status from the
                # second client is not NFS4ERR_DELAY
                xid = opencall.rpc.xid
                matchstr = "RPC.xid == %d and NFS.status in (%d, %d)" % (xid, NFS4_OK, NFS4ERR_DELAY)
                openreply = self.pktt.match(matchstr, maxindex=delegreturn_index)
                if openreply is None or openreply.nfs.status == NFS4_OK:
                    break

            if opencall is None:
                self.test(False, "%s should be sent from second client" % conflict_str)
                return
            conflict_index = opencall.record.index + 1

            if deleg_type == OPEN_DELEGATE_READ:
                self.pktt.rewind(save_index)
                # Verify no CB_RECALL is sent to client under test
                (cbcall, cbreply) = self.find_nfs_op(OP_CB_RECALL, ipaddr=self.client_ipaddr, port=None, src_ipaddr=self.server_ipaddr, maxindex=conflict_index)
                self.test(cbcall is None, "CB_RECALL should not be sent to the client after a READ OPEN is received from a second client")
                if deleg_stid1 != None:
                    self.test(cbcall is None, "CB_RECALL should not be sent to the client after a second client is granted a READ delegation")
                self.pktt.rewind(conflict_index)

            if lock:
                self.pktt.rewind(save_index)
                # Verify no CB_RECALL is sent to client under test
                (cbcall, cbreply) = self.find_nfs_op(OP_CB_RECALL, ipaddr=self.client_ipaddr, port=None, src_ipaddr=self.server_ipaddr, maxindex=conflict_index)
                self.test(cbcall is None, "%s delegation should not be recalled after locking the file" % mode_str)

                (lockcall, lockreply) = self.find_nfs_op(OP_LOCK, src_ipaddr=self.client_ipaddr, maxindex=conflict_index)
                self.test(lockcall is None, "LOCK should not be sent to the server when holding a %s delegation on the file" % mode_str)
                self.pktt.rewind(conflict_index)

            self.test(opencall, "%s should be sent from second client" % conflict_str)
            if conflict_op == OP_SETATTR:
                expr = opencall.NFSop.stateid.seqid == self.stateid_anonymous.seqid \
                   and opencall.NFSop.stateid.other == self.stateid_anonymous.other
                self.test(expr, "%s should be sent with the special anonymous stateid (0, 0)" % conflict_str)
            elif conflict_op == OP_REMOVE:
                expr = opencall.NFSop.name == self.filename
                self.test(expr, "%s should be sent with file holding the delegation as the name" % conflict_str)
            elif conflict_op == OP_RENAME:
                if target:
                    expr = opencall.NFSop.newname == self.filename
                    self.test(expr, "%s should be sent with file holding the delegation as the target" % conflict_str)
                else:
                    expr = opencall.NFSop.name == self.filename
                    self.test(expr, "%s should be sent with file holding the delegation as the source" % conflict_str)

            # Find CB_RECALL sent to client under test
            (cbcall, cbreply) = self.find_nfs_op(OP_CB_RECALL, ipaddr=self.client_ipaddr, port=None, src_ipaddr=self.server_ipaddr)
            self.test(cbcall != None, "CB_RECALL should be sent to the client after a conflicting %s is received from a second client" % conflict_str)
            if cbcall is None:
                return
            cbrecall_index = self.pktt.get_index()
            self.test(cbcall.NFSop.stateid.other == deleg_stid, "CB_RECALL should recall %s delegation granted to client" % mode_str)

            # Find OPEN sent from the client right before returning the delegation
            (fh, op_stid2, deleg_stid2) = self.find_open(filename=self.filename, deleg_stateid=deleg_stid, src_ipaddr=self.client_ipaddr, fh=open_fh)
            open_index = self.pktt.get_index()
            if fh is not None:
                self.test(op_stid2 != None, "OPEN with CLAIM_DELEGATE_CUR is sent from client right before returning the %s delegation after CB_RECALL" % mode_str)
                self.test(op_stid2 == open_stid, "OPEN stateid should be the same as the original OPEN stateid")
                self.test(deleg_stid2 is None, "Delegation should not be granted when re-opening the file right before returning the %s delegation after CB_RECALL" % mode_str)

            if deleg_type == OPEN_DELEGATE_WRITE:
                # Find out how much data has already been flushed right
                # before getting the CB_RECALL
                self.pktt.rewind(open1_index)
                nio = self.verify_io_requests(deleg_type, deleg_stid, filehandles, src_ipaddr=self.client_ipaddr, maxindex=cbrecall_index)
                if iosize > sum(self.test_counts):
                    # Not all data has been flushed,
                    # so find the WRITEs before DELEGRETURN
                    self.pktt.rewind(cbrecall_index)
                    nio = self.verify_io_requests(deleg_type, deleg_stid, filehandles, src_ipaddr=self.client_ipaddr, maxindex=open_index)
                    self.test(nio > 0, "Client flushes written data before returning the WRITE delegation")
                else:
                    self.test(True, "Client has already flushed all written data before CB_RECALL")
                self.pktt.rewind(open_index)

            lock_stid = None
            if lock and delegreturncall:
                self.pktt.rewind(open_index)
                # Find the LOCK before DELEGRETURN
                (lockcall, lockreply) = self.find_nfs_op(OP_LOCK, src_ipaddr=self.client_ipaddr, maxindex=delegreturn_index)
                self.test(lockcall != None, "LOCK is sent to the server right before returning the %s delegation" % mode_str)
                if lockreply and lockreply.nfs.status == NFS4_OK:
                    lock_stid = lockreply.NFSop.stateid.other

            self.test(delegreturncall != None, "DELEGRETURN should be sent from client right after re-opening the file")
            if delegreturncall is None:
                return
            self.test(delegreturncall.NFSop.stateid.other == deleg_stid, "DELEGRETURN should return the %s delegation being recalled" % mode_str)

            self.pktt.rewind(delegreturn_index)

            # Find OPEN reply from the second client
            xid = opencall.rpc.xid
            openreply = self.pktt.match("RPC.xid == %d and NFS.resop == %d" % (xid, conflict_op))
            self.test(openreply != None, "%s reply should be sent to the second client after the %s delegation has been returned" % (conflict_str, mode_str))
            if openreply is None:
                return
            mds_stat = [NFS4_OK]
            ds_stat  = [NFS4_OK]
            stateid = lock_stid if lock else open_stid
            if conflict_op == OP_OPEN:
                self.test(openreply.NFSop.delegation.deleg_type == OPEN_DELEGATE_NONE, "Delegation should not be granted for the second client")
            elif conflict_op == OP_REMOVE or (conflict_op == OP_RENAME and target):
                if deleg_type == OPEN_DELEGATE_WRITE:
                    ds_stat = [NFS4ERR_STALE, NFS4ERR_BAD_STATEID]
                else:
                    ds_stat = [NFS4ERR_BAD_STATEID]
                mds_stat = [NFS4ERR_STALE]

            # Verify I/O packets
            self.verify_io_packets(deleg_type, open_fh, lock, stateid, status=mds_stat, ds_status=ds_stat, delegret=True)
        except Exception:
            self.test(False, traceback.format_exc())

    def basic01_test(self):
        """Basic read delegation test"""
        self.basic_deleg_test(OPEN_DELEGATE_READ)

    def basic02_test(self):
        """Basic write delegation test"""
        self.basic_deleg_test(OPEN_DELEGATE_WRITE)

    def basic03_test(self):
        """Basic read delegation test with file stat"""
        self.basic_deleg_test(OPEN_DELEGATE_READ, stat=True)

    def basic04_test(self):
        """Basic write delegation test with file stat"""
        self.basic_deleg_test(OPEN_DELEGATE_WRITE, stat=True, nfiles=1)

    def basic05_test(self):
        """Basic read delegation test with file lock"""
        self.basic_deleg_test(OPEN_DELEGATE_READ, lock=True)

    def basic06_test(self):
        """Basic write delegation test with file lock"""
        self.basic_deleg_test(OPEN_DELEGATE_WRITE, lock=True)

    def recall01_test(self):
        """Recall read delegation by writing from a second client"""
        self.recall_deleg_test(OPEN_DELEGATE_READ)

    def recall02_test(self):
        """Recall write delegation by writing from a second client"""
        self.recall_deleg_test(OPEN_DELEGATE_WRITE)

    def recall03_test(self):
        """Recall read delegation by writing from a second client with file lock"""
        self.recall_deleg_test(OPEN_DELEGATE_READ, lock=True)

    def recall04_test(self):
        """Recall write delegation by writing from a second client with file lock"""
        self.recall_deleg_test(OPEN_DELEGATE_WRITE, lock=True)

    def recall05_test(self):
        """Recall write delegation by reading from a second client"""
        self.recall_deleg_test(OPEN_DELEGATE_WRITE, conflict_type=OPEN_DELEGATE_READ)

    def recall06_test(self):
        """Recall write delegation by reading from a second client with file lock"""
        self.recall_deleg_test(OPEN_DELEGATE_WRITE, conflict_type=OPEN_DELEGATE_READ, lock=True)

    def recall07_test(self):
        """Recall read delegation by changing the permissions to the file"""
        self.recall_deleg_test(OPEN_DELEGATE_READ, conflict_type=OP_SETATTR)

    def recall08_test(self):
        """Recall write delegation by changing the permissions to the file"""
        self.recall_deleg_test(OPEN_DELEGATE_WRITE, conflict_type=OP_SETATTR)

    def recall09_test(self):
        """Recall read delegation by changing the permissions to the file with file lock"""
        self.recall_deleg_test(OPEN_DELEGATE_READ, conflict_type=OP_SETATTR, lock=True)

    def recall10_test(self):
        """Recall write delegation by changing the permissions to the file with file lock"""
        self.recall_deleg_test(OPEN_DELEGATE_WRITE, conflict_type=OP_SETATTR, lock=True)

    def recall11_test(self):
        """Recall read delegation by removing the file"""
        self.recall_deleg_test(OPEN_DELEGATE_READ, conflict_type=OP_REMOVE, nfiles=1)

    def recall12_test(self):
        """Recall write delegation by removing the file"""
        self.recall_deleg_test(OPEN_DELEGATE_WRITE, conflict_type=OP_REMOVE, nfiles=1)

    def recall13_test(self):
        """Recall read delegation by removing the file with file lock"""
        self.recall_deleg_test(OPEN_DELEGATE_READ, conflict_type=OP_REMOVE, nfiles=1, lock=True)

    def recall14_test(self):
        """Recall write delegation by removing the file with file lock"""
        self.recall_deleg_test(OPEN_DELEGATE_WRITE, conflict_type=OP_REMOVE, nfiles=1, lock=True)

    def recall15_test(self):
        """Recall read delegation by renaming the file"""
        self.recall_deleg_test(OPEN_DELEGATE_READ, conflict_type=OP_RENAME, nfiles=1)

    def recall16_test(self):
        """Recall write delegation by renaming the file"""
        self.recall_deleg_test(OPEN_DELEGATE_WRITE, conflict_type=OP_RENAME, nfiles=1)

    def recall17_test(self):
        """Recall read delegation by renaming the file with file lock"""
        self.recall_deleg_test(OPEN_DELEGATE_READ, conflict_type=OP_RENAME, nfiles=1, lock=True)

    def recall18_test(self):
        """Recall write delegation by renaming the file with file lock"""
        self.recall_deleg_test(OPEN_DELEGATE_WRITE, conflict_type=OP_RENAME, nfiles=1, lock=True)

    def recall19_test(self):
        """Recall read delegation by renaming into the file"""
        self.recall_deleg_test(OPEN_DELEGATE_READ, conflict_type=OP_RENAME, nfiles=2, target=True)

    def recall20_test(self):
        """Recall write delegation by renaming into the file"""
        self.recall_deleg_test(OPEN_DELEGATE_WRITE, conflict_type=OP_RENAME, nfiles=2, target=True)

    def recall21_test(self):
        """Recall read delegation by renaming into the file with file lock"""
        self.recall_deleg_test(OPEN_DELEGATE_READ, conflict_type=OP_RENAME, nfiles=2, target=True, lock=True)

    def recall22_test(self):
        """Recall write delegation by renaming into the file with file lock"""
        self.recall_deleg_test(OPEN_DELEGATE_WRITE, conflict_type=OP_RENAME, nfiles=2, target=True, lock=True)

################################################################################
# Entry point
x = DelegTest(usage=USAGE, testnames=TESTNAMES, testgroups=TESTGROUPS, sid=SCRIPT_ID)

try:
    x.setup(nfiles=2)

    # Run all the tests
    x.run_tests()
except Exception:
    x.test(False, traceback.format_exc())
finally:
    if x.clientobj is not None and x.clientobj.mounted:
        # Unmount server on remote client
        x.clientobj.umount()
    x.cleanup()
    x.exit()
